---
title: "HW1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
По адресу http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция.
- Загрузите данные в датафрейм, который назовите ``data.df``.
```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
```
- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений и
```{r}
nrow(data.df)
```
27 переменных, то проверяйте аргументы.
```{r}
ncol(data.df)
```
- Получите имена колонок из ``data.df``.
```{r}
colnames(data.df)
```
- Найдите значение из 5 строки седьмого столбца.
```{r}
data.df[5,7]
```
- Напечатайте целиком 2 строку из ``data.df``
```{r}
data.df[2,]
```
- Объясните, что делает следующая строка кода 
```{r}
names(data.df) <- c("year", "month", "day", seq(0, 23))
```
Она изменяет названия столбцов
Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу.
```{r}
head(data.df)
```

```{r}
tail(data.df)
```
Что представляют собой последние 24 колонки?
Последние 24 колонки представляют данные за 80 год с 25 ноября по 30 ноября, поскольку данные равны набору нулей, осадков не было.
Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок.
```{r}
last_column_index <- length(colnames(data.df))
start_sum_column <- last_column_index - 23
data.df["daily"] <- rowSums(data.df[start_sum_column:start_sum_column])
```
Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
hist(data.df$daily)
```

Частота осадков почему-то отрицательная.
 Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку.
 Постройте новую гистограмму, поясните почему она более корректна.
```{r}
fixed.df <- data.df
fixed.df$daily <- abs(fixed.df$daily)
hist(fixed.df$daily)
```

## Синтаксис и типизирование
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
```{r eval=FALSE, include=FALSE}
v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
sum(v)
```
Неправильно произведена сортировка, найден максимум  и для суммирования передается неверный тип данных, это связано с тем, что данные в векторе мы задаем в виде текста.

* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.
```{r eval=FALSE, include=FALSE}
v2 <- c("5",7,12)
v2[2] + 2[3]
```
Нельзя сложить данные числового формата и текстового
```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```
Производится сложение только z2 и z3, только поэтому все работает
```{r eval=FALSE, include=FALSE}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]
```
В первом случае все работает, поскольку мы складываем значения 2 и 4 ячеек 1 строки, а во втором случае не работает, поскольку мы пытаемся сложить данные типа list

## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
    1. Числа от 1 до 10000 с инкрементом 372. 
    ```{r}
seq(1, 10000, by = 372)
```
    
    1. Числа от 1 до 10000 длиной 50.
    ```{r}
seq(1, 10000, length.out = 50)
```
* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.
Последовательность чисел от одного до пяти трижды последовательно повторяется.
```{r}
rep(1:5, times = 3)
```
Каждый элемент последовательности повторяется трижды, прежде чем выводится следующий.
```{r}
rep(1:5, each = 3)
```
